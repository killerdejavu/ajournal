import { format } from 'date-fns';

class JournalService {
  constructor(config, storage, aiService) {
    this.config = config.journal;
    this.storage = storage;
    this.aiService = aiService;
  }

  async generate(date) {
    try {
      const dateStr = format(date, 'yyyy-MM-dd');
      
      // Get raw data from all sources
      const rawData = await this.getRawDataForDate(date);
      
      // Normalize activities into a common format
      const activities = this.normalizeActivities(rawData);
      
      if (activities.length === 0) {
        console.log(`No activities found for ${dateStr}`);
        // Create a minimal journal even with no activities
        const emptyJournalContent = this.generateEmptyJournal(date);
        const journalPath = await this.storage.saveJournal(date, emptyJournalContent);
        return journalPath;
      }

      // Generate AI summary and insights
      const summary = await this.aiService.summarizeActivities(activities, date);
      const insights = await this.aiService.generateInsights(activities, date);
      const categorizedActivities = await this.aiService.categorizeActivities(activities);

      // Generate markdown journal
      const journalContent = this.generateMarkdown(date, activities, summary, insights, categorizedActivities);
      
      // Save journal
      const journalPath = await this.storage.saveJournal(date, journalContent);
      
      return journalPath;
    } catch (error) {
      console.error('Journal generation error:', error.message);
      throw error;
    }
  }

  async getRawDataForDate(date) {
    const dateStr = format(date, 'yyyy-MM-dd');
    const rawData = {};

    // Get Slack data
    const slackData = await this.storage.getRawData('slack', dateStr);
    if (slackData && slackData.data) {
      rawData.slack = slackData.data;
    }

    // Get GitHub data
    const githubData = await this.storage.getRawData('github', dateStr);
    if (githubData && githubData.data) {
      rawData.github = githubData.data;
    }

    // Get Google Calendar data
    const gcalData = await this.storage.getRawData('gcal', dateStr);
    if (gcalData && gcalData.data) {
      rawData.gcal = gcalData.data;
    }

    // Get JIRA data
    const jiraData = await this.storage.getRawData('jira', dateStr);
    if (jiraData && jiraData.data) {
      rawData.jira = jiraData.data;
    }

    return rawData;
  }

  normalizeActivities(rawData) {
    const activities = [];

    // Process Slack activities
    if (rawData.slack) {
      rawData.slack.forEach(activity => {
        activities.push({
          source: 'slack',
          timestamp: activity.timestamp,
          data: activity,
        });
      });
    }

    // Process GitHub activities
    if (rawData.github) {
      rawData.github.forEach(activity => {
        activities.push({
          source: 'github',
          timestamp: activity.timestamp,
          data: activity,
        });
      });
    }

    // Process Google Calendar activities
    if (rawData.gcal) {
      rawData.gcal.forEach(activity => {
        activities.push({
          source: 'gcal',
          timestamp: activity.timestamp,
          data: activity,
        });
      });
    }

    // Process JIRA activities
    if (rawData.jira) {
      rawData.jira.forEach(activity => {
        activities.push({
          source: 'jira',
          timestamp: activity.timestamp,
          data: activity,
        });
      });
    }

    // Sort by timestamp
    activities.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

    return activities;
  }

  generateEmptyJournal(date) {
    const dateStr = format(date, this.config.dateFormat);
    const dayName = format(date, 'EEEE');
    
    return `# ${dayName}, ${dateStr}

## Summary

No activities were recorded for this date.

## Notes

_You can add manual notes here about your day._

## Activities

No tracked activities found for ${dateStr}.

---

*Journal generated by AJournal on ${new Date().toLocaleString()}*
`;
  }

  generateMarkdown(date, activities, summary, insights, categorizedActivities) {
    const dateStr = format(date, this.config.dateFormat);
    const dayName = format(date, 'EEEE');
    
    let markdown = `# ${dayName}, ${dateStr}\n\n`;

    // Add AI-generated summary
    if (summary) {
      markdown += `## AI Summary\n\n${summary}\n\n`;
    }

    // Add insights if available
    if (insights) {
      markdown += `## Insights\n\n${insights}\n\n`;
    }

    // Add metrics if enabled
    if (this.config.includeMetrics) {
      const metrics = this.calculateDayMetrics(activities);
      markdown += this.generateMetricsSection(metrics);
    }

    // Add activities based on grouping preference
    if (this.config.groupBy === 'chronological') {
      markdown += this.generateChronologicalSection(activities);
    } else if (this.config.groupBy === 'by-tool') {
      markdown += this.generateByToolSection(activities);
    } else if (this.config.groupBy === 'by-project') {
      markdown += this.generateByProjectSection(categorizedActivities);
    }

    // Add raw data section if enabled
    if (this.config.includeRawData) {
      markdown += this.generateRawDataSection(activities);
    }

    // Add manual notes section
    markdown += `\n## Manual Notes\n\n<!-- Add your manual notes here -->\n\n`;

    // Add footer with generation timestamp
    markdown += `---\n*Generated on ${new Date().toISOString()} by AJournal*\n`;

    return markdown;
  }

  calculateDayMetrics(activities) {
    const metrics = {
      totalActivities: activities.length,
      slackMessages: activities.filter(a => a.source === 'slack').length,
      githubActivities: activities.filter(a => a.source === 'github').length,
      calendarEvents: activities.filter(a => a.source === 'gcal').length,
      jiraActivities: activities.filter(a => a.source === 'jira').length,
      meetingTime: 0,
      topChannels: {},
      topRepositories: {},
      topProjects: {},
      eventTypes: {},
    };

    // Calculate meeting time and collect stats
    activities.forEach(activity => {
      if (activity.source === 'gcal') {
        metrics.meetingTime += activity.data.duration / 60; // Convert to hours
        
        const eventType = activity.data.eventType;
        metrics.eventTypes[eventType] = (metrics.eventTypes[eventType] || 0) + 1;
      }

      if (activity.source === 'slack') {
        const channel = activity.data.channel;
        metrics.topChannels[channel] = (metrics.topChannels[channel] || 0) + 1;
      }

      if (activity.source === 'github') {
        const repo = activity.data.repository;
        metrics.topRepositories[repo] = (metrics.topRepositories[repo] || 0) + 1;
      }

      if (activity.source === 'jira') {
        const project = activity.data.project;
        metrics.topProjects[project] = (metrics.topProjects[project] || 0) + 1;
      }
    });

    // Sort top items
    metrics.topChannels = Object.entries(metrics.topChannels)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 5);

    metrics.topRepositories = Object.entries(metrics.topRepositories)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 5);

    metrics.topProjects = Object.entries(metrics.topProjects)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 5);

    return metrics;
  }

  generateMetricsSection(metrics) {
    let section = `## Daily Metrics\n\n`;
    
    section += `- **Total Activities**: ${metrics.totalActivities}\n`;
    section += `- **Slack Messages**: ${metrics.slackMessages}\n`;
    section += `- **GitHub Activities**: ${metrics.githubActivities}\n`;
    section += `- **Calendar Events**: ${metrics.calendarEvents}\n`;
    section += `- **JIRA Activities**: ${metrics.jiraActivities}\n`;
    section += `- **Meeting Time**: ${metrics.meetingTime.toFixed(1)} hours\n\n`;

    if (metrics.topChannels.length > 0) {
      section += `**Most Active Slack Channels:**\n`;
      metrics.topChannels.forEach(([channel, count]) => {
        section += `- #${channel}: ${count} messages\n`;
      });
      section += '\n';
    }

    if (metrics.topRepositories.length > 0) {
      section += `**Most Active Repositories:**\n`;
      metrics.topRepositories.forEach(([repo, count]) => {
        section += `- ${repo}: ${count} activities\n`;
      });
      section += '\n';
    }

    if (metrics.topProjects.length > 0) {
      section += `**Most Active JIRA Projects:**\n`;
      metrics.topProjects.forEach(([project, count]) => {
        section += `- ${project}: ${count} activities\n`;
      });
      section += '\n';
    }

    return section;
  }

  generateChronologicalSection(activities) {
    let section = `## Chronological Activity Log\n\n`;

    activities.forEach(activity => {
      const time = format(new Date(activity.timestamp), this.config.timeFormat);
      const description = this.getActivityDescription(activity);
      section += `**${time}** - ${description}\n\n`;
    });

    return section;
  }

  generateByToolSection(activities) {
    let section = '';

    const slackActivities = activities.filter(a => a.source === 'slack');
    const githubActivities = activities.filter(a => a.source === 'github');
    const calendarActivities = activities.filter(a => a.source === 'gcal');
    const jiraActivities = activities.filter(a => a.source === 'jira');

    if (calendarActivities.length > 0) {
      section += `## Calendar Events\n\n`;
      calendarActivities.forEach(activity => {
        const time = format(new Date(activity.timestamp), this.config.timeFormat);
        const data = activity.data;
        const duration = Math.round(data.duration / 60 * 100) / 100;
        section += `**${time}** - ${data.title} (${duration}h, ${data.attendeeCount} attendees)\n`;
        if (data.description) {
          section += `  *${data.description.substring(0, 100)}...*\n`;
        }
        section += '\n';
      });
    }

    if (githubActivities.length > 0) {
      section += `## GitHub Activities\n\n`;
      githubActivities.forEach(activity => {
        const time = format(new Date(activity.timestamp), this.config.timeFormat);
        const description = this.getActivityDescription(activity);
        section += `**${time}** - ${description}\n`;
        if (activity.data.url) {
          section += `  [View on GitHub](${activity.data.url})\n`;
        }
        section += `\n`;
      });
    }

    if (jiraActivities.length > 0) {
      section += `## JIRA Activities\n\n`;
      jiraActivities.forEach(activity => {
        const time = format(new Date(activity.timestamp), this.config.timeFormat);
        const description = this.getActivityDescription(activity);
        section += `**${time}** - ${description}\n`;
        if (activity.data.url) {
          section += `  [View Ticket](${activity.data.url})\n`;
        }
        section += `\n`;
      });
    }

    if (slackActivities.length > 0) {
      section += `## Slack Communications Summary\n\n`;
      const slackSummary = this.generateSlackSummary(slackActivities);
      section += slackSummary;
    }

    return section;
  }

  generateByProjectSection(categorizedActivities) {
    let section = '';

    for (const [category, activities] of Object.entries(categorizedActivities)) {
      if (Array.isArray(activities) && activities.length > 0) {
        section += `## ${category}\n\n`;
        
        activities.forEach(activity => {
          const time = format(new Date(activity.timestamp), this.config.timeFormat);
          const description = this.getActivityDescription(activity);
          section += `**${time}** - ${description}\n\n`;
        });
      }
    }

    return section;
  }

  generateRawDataSection(activities) {
    let section = `## Raw Data\n\n`;
    section += `<details>\n<summary>Click to expand raw data</summary>\n\n`;
    section += '```json\n';
    section += JSON.stringify(activities, null, 2);
    section += '\n```\n\n';
    section += '</details>\n\n';
    
    return section;
  }

  generateSlackSummary(slackActivities) {
    const channelStats = {};
    const intentStats = {};
    const typeStats = {};
    
    slackActivities.forEach(activity => {
      const data = activity.data;
      
      // Channel statistics
      channelStats[data.channel] = (channelStats[data.channel] || 0) + 1;
      
      // Intent statistics
      if (data.intent && Array.isArray(data.intent)) {
        data.intent.forEach(intent => {
          intentStats[intent] = (intentStats[intent] || 0) + 1;
        });
      }
      
      // Type statistics
      typeStats[data.type] = (typeStats[data.type] || 0) + 1;
    });

    let summary = `**Total Messages**: ${slackActivities.length}\n\n`;
    
    // Communication patterns
    summary += `**Communication Patterns:**\n`;
    const sortedIntents = Object.entries(intentStats)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 5);
    
    sortedIntents.forEach(([intent, count]) => {
      const percentage = Math.round((count / slackActivities.length) * 100);
      summary += `- ${intent.replace('_', ' ')}: ${count} messages (${percentage}%)\n`;
    });
    summary += '\n';
    
    // Channel breakdown
    summary += `**Channel Breakdown:**\n`;
    const sortedChannels = Object.entries(channelStats)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 8);
    
    sortedChannels.forEach(([channel, count]) => {
      summary += `- #${channel}: ${count} messages\n`;
    });
    summary += '\n';
    
    // Message types
    summary += `**Message Types:**\n`;
    Object.entries(typeStats).forEach(([type, count]) => {
      summary += `- ${type.replace('_', ' ')}: ${count}\n`;
    });
    summary += '\n';

    return summary;
  }

  getActivityDescription(activity) {
    const data = activity.data;
    
    switch (activity.source) {
      case 'slack':
        return `💬 **${data.type}** in #${data.channel}: "${data.text.substring(0, 100)}..."`;
      
      case 'github':
        if (data.type === 'pr_created') {
          return `🔧 **PR Created**: "${data.title}" in ${data.repository}`;
        } else if (data.type === 'pr_reviewed') {
          return `👁️ **PR Reviewed**: "${data.title}" in ${data.repository} (${data.reviewState})`;
        } else if (data.type === 'commit') {
          return `💻 **Commit**: "${data.message}" in ${data.repository}`;
        } else if (data.type === 'issue_activity') {
          return `🎯 **Issue**: "${data.title}" in ${data.repository}`;
        }
        return `🐙 **${data.type}** in ${data.repository}`;
      
      case 'gcal':
        const duration = Math.round(data.duration / 60 * 100) / 100;
        let icon = '📅';
        if (data.eventType === 'meeting') icon = '🤝';
        if (data.eventType === 'standup') icon = '🏃';
        if (data.eventType === 'one_on_one') icon = '👥';
        if (data.eventType === 'focus_time') icon = '🎯';
        
        return `${icon} **${data.eventType}**: "${data.title}" (${duration}h)`;
      
      case 'jira':
        let jiraIcon = '🎫';
        if (data.type === 'ticket_created') {
          jiraIcon = '🆕';
        } else if (data.type === 'ticket_updated') {
          jiraIcon = '🔄';
        } else if (data.type === 'comment_added') {
          jiraIcon = '💬';
        }
        
        let description = `${jiraIcon} **${data.type.replace('_', ' ')}**: "${data.summary}" in ${data.project}`;
        
        if (data.changes && data.changes.length > 0) {
          const changeText = data.changes.map(c => `${c.field}: ${c.from} → ${c.to}`).join(', ');
          description += ` (${changeText})`;
        }
        
        return description;
      
      default:
        return `${activity.source} activity`;
    }
  }
}

export default JournalService;